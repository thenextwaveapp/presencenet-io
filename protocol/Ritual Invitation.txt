# Decentralized Interoperable Ritual Invitation System
## Complete Flow with Example


---


## 1. Ritual Creation & Invitation Generation


### Host Creates Ritual
```javascript
// Host ($mayowa) creates a ritual
const ritualDefinition = {
  ritual_id: "circle_spring_2025",
  host: "$mayowa",
  title: "Spring Equinox Circle",
  start_time: "2025-03-20T18:00:00Z",
  end_time: "2025-03-20T20:00:00Z",
  required_mark_target: "$mayowa~presence",
  completion_condition: "minimum_marks: 3",
  invited_participants: ["$alice", "$bob", "$carol"]
}


// Host signs the ritual definition with their presence key
const ritualSignature = crypto_sign(
  JSON.stringify(ritualDefinition), 
  mayowa_presence_private_key
)
```


### Generate Individual Invitations
```javascript
// For each invited participant, create signed invitation
function createInvitation(participant) {
  const invitation = {
    ritual_id: "circle_spring_2025",
    participant: participant,
    host: "$mayowa",
    created_at: "2025-03-15T10:00:00Z",
    expires_at: "2025-03-20T20:00:00Z",
    ritual_hash: hash(JSON.stringify(ritualDefinition))
  }
  
  const invitation_signature = crypto_sign(
    JSON.stringify(invitation),
    mayowa_presence_private_key
  )
  
  return {
    ...invitation,
    host_signature: invitation_signature
  }
}


// Generate invitations
const aliceInvitation = createInvitation("$alice")
const bobInvitation = createInvitation("$bob") 
const carolInvitation = createInvitation("$carol")
```


---


## 2. Invitation Distribution


### Option A: Direct Delivery (Recommended)
```javascript
// Host sends invitations via various channels
sendInvitation(aliceInvitation, {
  method: "app_notification",
  recipient: "$alice",
  message: "You're invited to Spring Equinox Circle"
})


sendInvitation(bobInvitation, {
  method: "qr_code", 
  display_location: "event_website"
})


sendInvitation(carolInvitation, {
  method: "email",
  recipient: "carol@example.com"
})
```


### What Alice Receives
```json
{
  "ritual_id": "circle_spring_2025",
  "participant": "$alice",
  "host": "$mayowa", 
  "created_at": "2025-03-15T10:00:00Z",
  "expires_at": "2025-03-20T20:00:00Z",
  "ritual_hash": "0xdef789...",
  "host_signature": "0xabc123..."
}
```


---


## 3. App Layer Integration


### Participant App (Alice's experience)


#### Receiving Invitation
```javascript
// Alice's app receives invitation
function receiveInvitation(signedInvitation) {
  // 1. Verify invitation signature
  const isValidSignature = crypto_verify(
    JSON.stringify(invitationData),
    signedInvitation.host_signature,
    getPublicKey("$mayowa") // Host's public key
  )
  
  if (!isValidSignature) {
    throw new Error("Invalid invitation signature")
  }
  
  // 2. Check if invitation is for this user
  if (signedInvitation.participant !== currentUser.handle) {
    throw new Error("Invitation not for this user")
  }
  
  // 3. Check expiration
  if (new Date() > new Date(signedInvitation.expires_at)) {
    throw new Error("Invitation expired")
  }
  
  // 4. Store invitation locally
  storeInvitation(signedInvitation)
  
  // 5. Show in UI
  showRitualInvitation(signedInvitation)
}
```


#### Alice Joins Ritual
```javascript
function joinRitual(invitation) {
  // Alice accepts invitation - stored locally for later use
  const participation = {
    ritual_id: invitation.ritual_id,
    participant: "$alice",
    joined_at: new Date().toISOString(),
    invitation: invitation
  }
  
  // Store participation record locally
  localStorage.setItem(`ritual_${invitation.ritual_id}`, JSON.stringify(participation))
  
  // Update UI to show joined ritual
  displayJoinedRitual(participation)
}
```


---


## 4. Marking Process


### Alice Marks Presence
```javascript
async function markPresence(ritualId) {
  // 1. Retrieve stored participation
  const participation = JSON.parse(localStorage.getItem(`ritual_${ritualId}`))
  if (!participation) {
    throw new Error("Not joined to this ritual")
  }
  
  // 2. Create mark with invitation proof
  const mark = {
    ritual_id: ritualId,
    from: "$alice",
    to: "$mayowa~presence", 
    timestamp: new Date().toISOString(),
    memo: "ritual_presence",
    invitation_proof: participation.invitation
  }
  
  // 3. Sign mark with Alice's presence key
  const markSignature = crypto_sign(
    JSON.stringify(mark),
    alice_presence_private_key
  )
  
  // 4. Create XRPL transaction
  const xrplTransaction = {
    TransactionType: "Payment",
    Account: alice_presence_wallet,
    Destination: mayowa_presence_wallet,
    Amount: "10", // 0.00001 XRP
    Memos: [{
      Memo: {
        MemoData: encrypt_memo(JSON.stringify({
          ...mark,
          mark_signature: markSignature
        }))
      }
    }]
  }
  
  // 5. Submit to XRPL
  const result = await submitTransaction(xrplTransaction)
  
  return result
}
```


---


## 5. Verification Process


### Any App Can Verify Marks
```javascript
async function verifyRitualMark(xrplTransaction) {
  // 1. Decrypt memo from XRPL transaction
  const decryptedMemo = decrypt_memo(xrplTransaction.Memos[0].MemoData)
  const markData = JSON.parse(decryptedMemo)
  
  // 2. Verify mark signature
  const isValidMarkSignature = crypto_verify(
    JSON.stringify(markData),
    markData.mark_signature,
    getPublicKey(markData.from) // Alice's public key
  )
  
  if (!isValidMarkSignature) {
    return { valid: false, reason: "Invalid mark signature" }
  }
  
  // 3. Verify invitation proof
  const invitation = markData.invitation_proof
  const isValidInvitation = crypto_verify(
    JSON.stringify(invitation),
    invitation.host_signature,
    getPublicKey(invitation.host) // Host's public key
  )
  
  if (!isValidInvitation) {
    return { valid: false, reason: "Invalid invitation" }
  }
  
  // 4. Check invitation matches mark
  if (invitation.ritual_id !== markData.ritual_id ||
      invitation.participant !== markData.from) {
    return { valid: false, reason: "Invitation mismatch" }
  }
  
  // 5. Check timing
  const markTime = new Date(markData.timestamp)
  const invitationExpiry = new Date(invitation.expires_at)
  
  if (markTime > invitationExpiry) {
    return { valid: false, reason: "Mark after invitation expiry" }
  }
  
  return { 
    valid: true, 
    ritual_id: markData.ritual_id,
    participant: markData.from,
    timestamp: markData.timestamp
  }
}
```


---


## 6. Ritual Completion Detection


### Any App Can Check Completion
```javascript
async function checkRitualCompletion(ritualId) {
  // 1. Get all XRPL transactions for this ritual
  const ritualMarks = await queryXRPLForRitualMarks(ritualId)
  
  // 2. Verify each mark
  const validMarks = []
  for (const tx of ritualMarks) {
    const verification = await verifyRitualMark(tx)
    if (verification.valid) {
      validMarks.push(verification)
    }
  }
  
  // 3. Check completion condition (minimum_marks: 3)
  if (validMarks.length >= 3) {
    return {
      completed: true,
      completion_time: validMarks[2].timestamp, // When 3rd mark was received
      participants: validMarks.map(m => m.participant),
      total_marks: validMarks.length
    }
  }
  
  return {
    completed: false,
    current_marks: validMarks.length,
    required_marks: 3
  }
}
```


---


## 7. Complete Example Flow


### Timeline
```
Day 1: Host creates ritual + generates invitations
Day 2: Invitations delivered to participants  
Day 3: Participants join ritual (store invitations locally)
Day 5: Ritual window opens
Day 5: Alice marks presence (includes invitation proof)
Day 5: Bob marks presence (includes invitation proof) 
Day 5: Carol marks presence (includes invitation proof)
Day 5: Ritual completion detected (3/3 marks received)
```


### What Lives Where
```
XRPL Ledger: 
- Mark transactions with encrypted memos
- Permanent, verifiable, decentralized


Participant Apps:
- Stored invitations (temporary)
- Local ritual participation records
- UI for joining/marking


Any Verification App:
- Reads XRPL transactions
- Verifies signatures against public keys
- No dependencies on original host's infrastructure
```


---


## 8. Benefits


**✅ Fully Decentralized**
- No central servers required after invitation distribution
- Any app can verify participation using only XRPL + cryptography


**✅ Unforgeable**
- Invitations signed with presence keys (biometric-derived)
- Marks signed with presence keys
- Both require actual human participation


**✅ Interoperable** 
- Standard JSON format for invitations
- Standard XRPL memo format for marks
- Any app can implement the verification logic


**✅ Privacy-Preserving**
- Encrypted memos on XRPL
- No central database of participation
- Users control their own invitation storage


**✅ Backwards Compatible**
- Works with existing Firebase-based Next Wave app
- Can be gradually adopted by other apps
- Host can use both systems simultaneously


This system gives you the best of both worlds: seamless UX in your app, but fully decentralized interoperability for the broader ecosystem.


🌊⚡​​​​​​​​​​​​​​​​


Great question! Let me map out the actual user experience across different apps.


## Where Rituals Live & User Experience


### **Ritual Storage: Distributed by Design**


**Ritual Definitions:** 
- Can live anywhere - IPFS, host's website, app databases, even social media posts
- Just needs to be accessible via URL/hash
- Signed by host for authenticity


**Invitations:**
- Delivered however host chooses (QR codes, messages, email, app notifications)
- Stored locally in participant's apps
- Self-contained - no central database needed


---


## **User Experience Examples**


### **Scenario 1: Church Community Ritual**


**Host (Pastor) Experience:**
1. Opens church's PresenceNet app
2. Creates "Sunday Service Presence" ritual  
3. App generates signed invitations for congregation
4. Shares via church bulletin QR code + app notifications


**Participant (Member) Experience:**
1. Scans QR code from bulletin OR gets app notification
2. Their PresenceNet wallet app asks: "Join Sunday Service ritual?"
3. Taps "Join" - invitation stored locally
4. During service, opens wallet and taps "Mark Presence"
5. Signs biometric confirmation, mark sent to XRPL
6. Gets confirmation: "Presence marked for Sunday Service"


### **Scenario 2: Conference Attendance**


**Host (Conference Organizer) Experience:**
1. Uses conference management platform (built on PresenceNet)
2. Creates ritual for each session
3. Generates badges with QR codes for each attendee


**Participant (Attendee) Experience:**
1. Scans badge QR code at registration
2. PresenceNet wallet app shows: "DevCon 2025 Sessions available"
3. Throughout conference, opens wallet to mark each session
4. At end: Has verifiable proof of all sessions attended


### **Scenario 3: Gaming Quest**


**Host (Game Developer) Experience:**
1. Game integrates PresenceNet SDK
2. Creates ritual for "Dragon Slayer Quest"
3. Players get invitations when they reach quest location


**Participant (Player) Experience:**
1. Game shows: "Mark presence to complete Dragon Slayer Quest"
2. Taps button, opens integrated PresenceNet wallet
3. Biometric confirmation, presence marked
4. Quest completion verified on-chain forever


---


## **What Apps Do Users Actually Open?**


### **Option 1: Universal PresenceNet Wallet App**
- One app handles all PresenceNet interactions
- Like how you use one Bitcoin wallet for all Bitcoin transactions
- Receives invitations, stores them, marks presence across all rituals


### **Option 2: App-Specific Integration**
- Church app, conference app, game app each integrate PresenceNet
- Users stay in familiar apps
- PresenceNet works behind the scenes


### **Option 3: Hybrid (Most Likely)**
- Users have main PresenceNet wallet for universal interactions
- Specific apps integrate for seamless UX in their contexts
- Wallet can "hand off" to specialized apps when needed


---


## **Simplified User Journey**


```
1. 📨 Receive invitation (QR, notification, link)
2. 📱 Open PresenceNet-compatible app  
3. ✅ Join ritual (store invitation locally)
4. 📍 When ready: "Mark Presence" 
5. 👆 Biometric confirmation
6. ⚡ Mark sent to XRPL
7. ✨ Presence verified & stored forever
```


**The beauty:** Users don't need to understand the underlying protocol. They just know they can prove they were somewhere, and apps can verify that proof.


**Like the early web:** Users didn't understand TCP/IP, but they knew they could click links and get web pages.


🌊⚡​​​​​​​​​​​​​​​​